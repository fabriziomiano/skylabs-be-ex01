"""Endpoints definition"""import pandas as pdfrom flask import request, jsonify, make_response, abort, current_app as appfrom app import db, jsqlfrom app.api import apifrom app.models import (    Country, EducationLevel, MaritalStatus, Occupation, Race, Record,    Relationship, Sex, WorkClass)STATS_QUERY_TEMPLATE = (    """    SELECT '{{ aggregation_type|sqlsafe }}' [aggregationType]     , {{ aggregation_value|sqlsafe }} [aggregationFilter]     , SUM(r.capital_gain) [capital_gain_sum]     , AVG(r.capital_gain) [capital_gain_avg]     , SUM(r.capital_loss) [capital_loss_sum]     , AVG(r.capital_loss) [capital_loss_avg]     , SUM(CASE WHEN r.over_50k = 1 THEN 1 ELSE 0 END) [over_50k_count]     , SUM(CASE WHEN r.over_50k = 0 THEN 1 ELSE 0 END) [under_50k_count]     FROM records r     WHERE r.{{ aggregation_type|sqlsafe }} = {{ aggregation_value|sqlsafe }}    """)def unnormalized_records_query():    """    Return an unnormalized records query object    :return: db.session.query    """    return db.session.query(        Record,        Country.name.label('country_name'),        EducationLevel.name.label('education_level_name'),        MaritalStatus.name.label('marital_status_name'),        Occupation.name.label('occupation_name'),        Race.name.label('race_name'),        Relationship.name.label('relationship_name'),        Sex.name.label('sex_name'),        WorkClass.name.label('workclass_name')    ).join(Country). \        join(EducationLevel). \        join(MaritalStatus). \        join(Occupation). \        join(Race). \        join(Relationship). \        join(Sex). \        join(WorkClass)@api.route('/records')@api.route('/records/page/<int:page>')def get_unnormalized_records(page=None):    """    Return a JSON-formatted list of records.    Examples:        - for all the records        /records        - for parametric pagination        /records/page/<page>?per_page=<per_page>            page: int            per_page: int, optional: defaults to 25 if not specified    :param page: int    :return: string    """    app.logger.info("Received all records request")    query = unnormalized_records_query()    if page is not None:        if page < 1:            abort(404)        try:            per_page = int(request.args.get("per_page"))        except TypeError:            per_page = 25        query = unnormalized_records_query()        query = query.limit(per_page).offset((page - 1) * per_page)    df = pd.read_sql(query.statement, query.session.bind)    if df.empty:        abort(404)    return jsonify(*df.to_dict(orient='records'))@api.route('/stats', methods=['GET', 'POST'])def get_stats():    """    Return aggregated statistics in the following JSON-formatted form    {        "aggregationType": "string",        "aggregationFilter": int,        "capital_gain_sum": float,        "capital_gain_avg": float,        "capital_loss_sum": float,        "capital_loss_avg": float,        "over_50k_count": int,        "under_50k_count": int    }    Two parameters are expected:        - aggregationType: "string"            must be one of ["age", "education_level_id", "occupation_id"]        - aggregationValue: int    :return: string    """    accepted_aggregation_types = ("age", "education_level_id", "occupation_id")    req_args = request.args    aggregation_type = req_args.get('aggregationType')    aggregation_value = req_args.get('aggregationValue')    app.logger.info(f'Received stats request {req_args}')    if not aggregation_type or not aggregation_value:        abort(400)    try:        assert aggregation_type in accepted_aggregation_types    except AssertionError:        return jsonify({            'error': f'aggregationType must be in {accepted_aggregation_types}'        })    try:        aggregation_value = int(aggregation_value)        q_params = {            "aggregation_type": aggregation_type,            "aggregation_value": aggregation_value        }        query, _ = jsql.prepare_query(STATS_QUERY_TEMPLATE, q_params)        df = pd.read_sql(query, db.session.bind)        response = df.to_dict(orient='records')    except ValueError:        msg = 'aggregationValue must be of type int'        response = {'error': msg}    return jsonify(response)@api.route('/csv')def get_csv():    """    Download a CSV containing all the unnormalized data    :return: Flask.Response object    """    app.logger.info('Received request to download CSV')    try:        query = unnormalized_records_query()        df = pd.read_sql(query.statement, query.session.bind)        filename = app.config['ALL_RECORDS_CSV_FILENAME']        response = make_response(df.to_csv(index=False))        response.headers['Content-Disposition'] = (            f"attachment;filename={filename}")        response.headers['Content-Type'] = "text/csv"        status_code = 200    except Exception as e:        err_msg = f'While building data frame: {e}'        app.logger.error(err_msg)        response = jsonify({"status": "ko", "error": err_msg})        status_code = 500    return response, status_code